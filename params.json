{"name":"Turrisclock","tagline":"Driving clock movement from the Turris router","body":"This is a hardware and software design allowing you to connect common quartz analog clock movement to a [Turris router](https://www.turris.cz) and let it be controlled by it. Such clock has some ultimate features:\r\n\r\n* precise atomic time thanks to NTP\r\n* ability to pause and resume movement at any moment (no more ticking disturbing your sleep)\r\n* battery-free operation\r\n* special effects like stepping 5 seconds at time\r\n\r\n## Hardware\r\n\r\nCarefully disassemble the clock machine. Hook up two wires directly to the [Lavet type stepping motor](http://en.wikipedia.org/wiki/Lavet_type_stepping_motor) winding. You can take out the original circuitry or let it in place. In the latter case, make sure you disconnect at least one wire of the winding from the original circuitry.\r\n\r\n## Hardware interface\r\n\r\n![Interface schematics](https://raw.githubusercontent.com/oskar456/turrisclock/eagle/schematics.png)\r\n\r\nDesign files for the interface are available in the [eagle branch](https://github.com/oskar456/turrisclock/tree/eagle). It has been made using [EAGLE 7.2.0](http://www.cadsoftusa.com/eagle-pcb-design-software/product-overview/?language=en). The interface connect the clock motor to GPIO connector ([P3 on the Turris board](https://www.turris.cz/doc/_media/turris_pinout-v1_2.pdf)) via 10-wire flat ribbon cable.\r\n\r\n## Software\r\n\r\nSoftware is written in Python 2. Since there is no feedback about current state of the clock face, the user have to provide current state when running the clock for the first time:\r\n\r\n    ./turrisclock.py --state 12:34:56\r\n\r\nAfter regular shutdown of the control software, the state of the clock is written to `/root/clockstate.txt`, from which it is reloaded on next start.\r\n\r\n### Adjust polarity\r\n\r\nSince Lavet motor requires polarized control pulses, there may be a situation when the clock appears one second slow. In that case, the polarity of control pulses has to be inverted. It can be done in hardware by exchanging the wires connecting the Lavet motor, or it can be done by using switch ``--invert``. Information about polarity inversion is also stored with the clock state.\r\n\r\n### Goto utility\r\n\r\nIn order to set the clock to some arbitrary state, a simple utility can be used:\r\n\r\n    ./goto.py 12:00:00\r\n\r\n### Stepping more seconds at time\r\n\r\nYou can make the clock go n-seconds at time by using switch `-s <n>`\r\n\r\n### Waiting with comfort steps\r\n\r\nWhen the clock state is just a few minutes ahead of current time, it's usually not feasible to go fast forward all around the clock. Doing so would take much more time than just waiting until current time reaches the clock state. The software therefore computes what approach is better and act accordingly. To appease users during waiting, a comfort step is inserted every 10 seconds (configurable with `-c` command line argument).\r\n\r\n## Known issues\r\n\r\n### Clock losing steps, especially during fast-forward movement\r\n* problem is usually in poor quality of the clockwork, eg. unbalanced hands, big backlash, etc.\r\n* you can try adjusting time constants `ontime` and `offtime` [in `clock.py'](https://github.com/oskar456/turrisclock/blob/master/clock.py#L11)\r\n\r\n### Clock state is lost when the router loses power\r\nThis could be solved by saving the clock state after every step into the SRAM of battery-backed RTC chip inside Turris. However, there is no driver support for this RAM yet.\r\n\r\n### Running two instances of the software results is strange behaviour\r\nLocking is not implemented yet. Patches are welcome!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}